dat4 <- lapply(unique(ties$pos), function(i) {
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
# recursion of previous ranking method
ss2 <- rbind(ss1 %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
ss1 %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first order ranking
ss3 <- ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga, randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
# # check for ties
# ss_ties <- ss3 %>%
#   group_by(pos) %>%
#   summarise(n = n()) %>%
#   filter(n > 1)
#
# # if still ties
# if(any(ss_ties$n > 1)) {
#   # then cointoss (randomiser to account for >1 tied team)
#   ss3 <- ss3 %>%
#     mutate(randomiser = runif(n(), 0, 1)) %>%
#     arrange(-randomiser)
# }
}) %>%
plyr::rbind.fill()
# re-rank by new tiebreaker variables
dat3 <- left_join(dat3, dat4, by = c("Group", "team")) %>%
arrange(-pts, -gd, -gf, -h2h.pts, -h2h.gf, -h2h.gd, -randomiser) %>%
mutate(pos = 1:n()) %>%
select(Group, pos, team, pts, gf, ga, gd)
}
dat3 %>%
select(Group, pos, team, pts, gf, ga, gd)
}
d %>% filter(iter %in% 27) %>% filter(round == 0) %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1:27) %>% filter(round == 0) %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0) %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "A") %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "H") %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "G") %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "F") %>% group_by(iter, Group) %>% do(makeTable(.))
dat <- d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "F")
# lengthen results dataframe
dat2 <- rbind(dat %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
dat %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first ranking
dat3 <- dat2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], pts = as.integer(sum(pts)), gf = sum(gf), ga = sum(ga), gd = gf - ga) %>%
arrange(-pts, -gd, -gf)
# rank descending by multiple variables in decreasing order of importance
dat3 <- dat3 %>%
mutate(score = pts*1e5 + gd*1e3 + gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score)
dat3
# check for ties
ties <- dat3 %>%
group_by(pos) %>%
summarise(n = n()) %>%
filter(n > 1)
ties
ties$pos
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
# recursion of previous ranking method
ss2 <- rbind(ss1 %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
ss1 %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first order ranking
ss3 <- ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga, randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
ss3
ss2
ss1
dat3
i
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
teams
# first ranking
dat3 <- dat2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], pts = as.integer(sum(pts)), gf = sum(gf), ga = sum(ga), gd = gf - ga) %>%
arrange(-pts, -gd, -gf)
# rank descending by multiple variables in decreasing order of importance
dat3 <- dat3 %>%
mutate(score = pts*1e5 + gd*1e3 + gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score)
dat3
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
ss1
dat3
dat3[dat3$pos == i,]$team
i
ties
unique(ties$pos)
i <- ss3
unique(ties$pos) -> i
i
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
teams
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
# recursion of previous ranking method
ss2 <- rbind(ss1 %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
ss1 %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
ss2
# first order ranking
ss3 <- ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga, randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1)))
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga, randomiser = runif(n(), 0, 1))
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga
)
# first order ranking
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga) %>%
mutate(randomiser = runif(n(), 0, 1) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
# # check for ties
# ss_ties <- ss3 %>%
#   group_by(pos) %>%
#   summarise(n = n()) %>%
#   filter(n > 1)
#
# # if still ties
# if(any(ss_ties$n > 1)) {
#   # then cointoss (randomiser to account for >1 tied team)
#   ss3 <- ss3 %>%
#     mutate(randomiser = runif(n(), 0, 1)) %>%
#     arrange(-randomiser)
# }
}) %>%
plyr::rbind.fill()
# first order ranking
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga) %>%
mutate(randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
# for each tie
dat4 <- lapply(unique(ties$pos), function(i) {
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
# recursion of previous ranking method
ss2 <- rbind(ss1 %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
ss1 %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first order ranking
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga) %>%
mutate(randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
# # check for ties
# ss_ties <- ss3 %>%
#   group_by(pos) %>%
#   summarise(n = n()) %>%
#   filter(n > 1)
#
# # if still ties
# if(any(ss_ties$n > 1)) {
#   # then cointoss (randomiser to account for >1 tied team)
#   ss3 <- ss3 %>%
#     mutate(randomiser = runif(n(), 0, 1)) %>%
#     arrange(-randomiser)
# }
}) %>%
plyr::rbind.fill()
# re-rank by new tiebreaker variables
dat3 <- left_join(dat3, dat4, by = c("Group", "team")) %>%
arrange(-pts, -gd, -gf, -h2h.pts, -h2h.gf, -h2h.gd, -randomiser) %>%
mutate(pos = 1:n()) %>%
select(Group, pos, team, pts, gf, ga, gd)
dat3
dat3 %>%
select(Group, pos, team, pts, gf, ga, gd)
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "F") %>% group_by(iter, Group) %>% do(makeTable(.))
makeTable <- function(dat) {
# lengthen results dataframe
dat2 <- rbind(dat %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
dat %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first ranking
dat3 <- dat2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], pts = as.integer(sum(pts)), gf = sum(gf), ga = sum(ga), gd = gf - ga) %>%
arrange(-pts, -gd, -gf)
# rank descending by multiple variables in decreasing order of importance
dat3 <- dat3 %>%
mutate(score = pts*1e5 + gd*1e3 + gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score)
# check for ties
ties <- dat3 %>%
group_by(pos) %>%
summarise(n = n()) %>%
filter(n > 1)
# if ties
if(any(ties$n > 1)) {
# for each tie
dat4 <- lapply(unique(ties$pos), function(i) {
# create mini-league from tied teams fixtures
teams <- dat3[dat3$pos == i,]$team
ss1 <- dat[dat$team1 %in% teams & dat$team2 %in% teams,]
# recursion of previous ranking method
ss2 <- rbind(ss1 %>%
select(Group, team = team1, opp = team2, gf = ft.A, ga = ft.B),
ss1 %>%
select(Group, team = team2, opp = team1, gf = ft.B, ga = ft.A))
# first order ranking
ss2 %>%
mutate(pts = if_else(gf > ga, 3, if_else(gf < ga, 0, 1))) %>%
group_by(team) %>%
summarise(Group = Group[1], h2h.pts = as.integer(sum(pts)), h2h.gf = sum(gf), h2h.ga = sum(ga), h2h.gd = h2h.gf - h2h.ga) %>%
mutate(randomiser = runif(n(), 0, 1)) %>%
arrange(-h2h.pts, -h2h.gd, -h2h.gf, -randomiser) %>%
mutate(score = h2h.pts*1e5 + h2h.gd*1e3 + h2h.gf) %>%
mutate(pos = dense_rank(-score)) %>%
select(-score, -h2h.ga, -pos)
# # check for ties
# ss_ties <- ss3 %>%
#   group_by(pos) %>%
#   summarise(n = n()) %>%
#   filter(n > 1)
#
# # if still ties
# if(any(ss_ties$n > 1)) {
#   # then cointoss (randomiser to account for >1 tied team)
#   ss3 <- ss3 %>%
#     mutate(randomiser = runif(n(), 0, 1)) %>%
#     arrange(-randomiser)
# }
}) %>%
plyr::rbind.fill()
# re-rank by new tiebreaker variables
dat3 <- left_join(dat3, dat4, by = c("Group", "team")) %>%
arrange(-pts, -gd, -gf, -h2h.pts, -h2h.gf, -h2h.gd, -randomiser) %>%
mutate(pos = 1:n()) %>%
select(Group, pos, team, pts, gf, ga, gd)
}
dat3 %>%
select(Group, pos, team, pts, gf, ga, gd)
}
d %>% filter(iter %in% 1) %>% filter(round == 0 & Group == "F") %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1) %>% filter(round == 0) %>% group_by(iter, Group) %>% do(makeTable(.))
d %>% filter(iter %in% 1:10) %>% filter(round == 0) %>% group_by(iter, Group) %>% do(makeTable(.))
probTables <- function(dat) {
dat2 <- dat %>%
group_by(iter) %>%
slice(1:48) %>%
group_by(iter, Group) %>%
do(makeTable(.)) %>%
as.data.frame() %>%
group_by(iter) %>%
mutate(pos = rep(1:4, 8)) %>%
ungroup() %>%
group_by(Group, team) %>%
mutate(n = n()) %>%
group_by(Group, team, pos) %>%
summarise(pc = n() / n[1])
scaffold <- dat2 %>%
group_by(Group, team) %>%
slice(1) %>%
expand(pos = 1:4) %>%
mutate(pc = 0)
dat3 <- merge(dat2, scaffold, all = T) %>%
group_by(Group, team, pos) %>%
arrange(-pc) %>%
slice(1)
# create scores to generate a rank order of predicted positions
preds <- dat3 %>%
group_by(Group, team) %>%
arrange(Group, team, pos) %>%
mutate(score = pc[1]*4 + pc[2]*3 + pc[3]*2 + pc[4]) %>%
summarise(score = score[1]) %>%
arrange(Group, -score) %>%
mutate(pred = 1:4)
dat4 <- left_join(dat3, preds, by = c("Group", "team"))
dat4 %>%
arrange(Group, pos) %>%
mutate(pc = round(pc, 2))
}
probTables(filter(dat, iter %in% 1:10))
dat <- d %>% filter(iter %in% 1:10) %>% filter(round == 0)
dat
dat2 <- dat %>%
filter(round == 0) %>%
group_by(iter) %>%
group_by(iter, Group) %>%
do(makeTable(.)) %>%
as.data.frame() %>%
group_by(iter) %>%
mutate(pos = rep(1:4, 8)) %>%
ungroup() %>%
group_by(Group, team) %>%
mutate(n = n()) %>%
group_by(Group, team, pos) %>%
summarise(pc = n() / n[1])
dat2
filter(dat2, Group == "A")
scaffold <- dat2 %>%
group_by(Group, team) %>%
slice(1) %>%
expand(pos = 1:4) %>%
mutate(pc = 0)
dat3 <- merge(dat2, scaffold, all = T) %>%
group_by(Group, team, pos) %>%
arrange(-pc) %>%
slice(1)
dat3
# create scores to generate a rank order of predicted positions
preds <- dat3 %>%
group_by(Group, team) %>%
arrange(Group, team, pos) %>%
mutate(score = pc[1]*4 + pc[2]*3 + pc[3]*2 + pc[4]) %>%
summarise(score = score[1]) %>%
arrange(Group, -score) %>%
mutate(pred = 1:4)
preds
dat4 <- left_join(dat3, preds, by = c("Group", "team"))
dat4 %>%
arrange(Group, pos) %>%
mutate(pc = round(pc, 2))
probTables <- function(dat) {
dat2 <- dat %>%
filter(round == 0) %>%
group_by(iter) %>%
group_by(iter, Group) %>%
do(makeTable(.)) %>%
as.data.frame() %>%
group_by(iter) %>%
mutate(pos = rep(1:4, 8)) %>%
ungroup() %>%
group_by(Group, team) %>%
mutate(n = n()) %>%
group_by(Group, team, pos) %>%
summarise(pc = n() / n[1])
scaffold <- dat2 %>%
group_by(Group, team) %>%
slice(1) %>%
expand(pos = 1:4) %>%
mutate(pc = 0)
dat3 <- merge(dat2, scaffold, all = T) %>%
group_by(Group, team, pos) %>%
arrange(-pc) %>%
slice(1)
# create scores to generate a rank order of predicted positions
preds <- dat3 %>%
group_by(Group, team) %>%
arrange(Group, team, pos) %>%
mutate(score = pc[1]*4 + pc[2]*3 + pc[3]*2 + pc[4]) %>%
summarise(score = score[1]) %>%
arrange(Group, -score) %>%
mutate(pred = 1:4)
dat4 <- left_join(dat3, preds, by = c("Group", "team"))
dat4 %>%
arrange(Group, pos) %>%
mutate(pc = round(pc, 2))
}
probTables(filter(dat, iter %in% 1:10))
d2 <- probTables(filter(d, iter %in% 1:10))
d2
d2 <- probTables(filter(d, iter %in% 1:100))
plotTables(d2)
rm(list=ls())
unlog.forecast <- function(fc) {
fc$mean<-exp(fc$mean) - 1
fc$upper<-exp(fc$upper) - 1
fc$lower<-exp(fc$lower) - 1
fc$x<-exp(fc$x)
return(fc)
}
tbats.forecast <- function(dat, fc_date = "2017-03-01", h = 30) {
#subset data
# fc_date <- as.Date(fc_date)
dat <- subset(dat, date < fc_date)
#time series
dataseries <- ts(dat$sessions, start = c(2015,12,1), frequency = 365)
#take logs
dataseries <- log(dataseries + 1)
#weekly and yearly seasonality
y <- msts(dataseries, seasonal.periods=c(7,365.25))
# fit TBATS
fit <- tbats(y)
#forecast
fc <- forecast(fit, h = h)
# exponentiate forecasts
fc$mean<-exp(fc$mean) - 1
fc$upper<-exp(fc$upper) - 1
fc$lower<-exp(fc$lower) - 1
fc$x<-exp(fc$x)
return(fc)
}
d <- queryRS("SELECT date, SUM(newusers) AS newusers FROM geodata GROUP BY date ORDER BY date")
# fit time series with decimal date
y <- ts(d$newusers, start = c(2015, 12, 1), frequency = 365)
# log transform
y.log <- ts(log(d$newusers+1), start = c(2015, 12, 1), frequency = 365)
# transform raw to multi-seasonal time series
y2 <- msts(d$newusers, seasonal.periods=c(7,365), ts.frequency = 365.25, start = c(2015, 12, 1)) #weekly and yearly seasonality
# transform log to multi-seasonal ts
y2.log <- msts(log(d$newusers+1), seasonal.periods=c(7,365), ts.frequency = 365.25, start = c(2015, 12, 1)) #weekly and yearly seasonality
# 2. TBATS
fit.tbats <- tbats(y2.log)
fc.tbats <- forecast(fit.tbats, h = 90, level = c(68, 95))
fc.tbats <- unlog.forecast(fc.tbats)
plot(fc.tbats)
# combine actual and predicted data as dataframe
fc.df1 <- data.frame(date = d$date, y = d$newusers, type = "actual")
fc.df2 <- as.data.frame(fc.tbats) %>%
mutate(date = seq(max(d$date) + 1, max(d$date) + 90, by = 1)) %>%
mutate(type = "predicted") %>%
select(date, type, y = "Point Forecast", lo.68 = "Lo 68", hi.68 = "Hi 68", lo.95 = "Lo 95", hi.95 = "Hi 95")
fc.df <- plyr::rbind.fill(fc.df1, fc.df2)
# plot all-time overview with simple moving average fitted to actual data
p <- ggplot(fc.df, aes(date, y, colour = type, size = type)) +
geom_line() +
geom_ribbon(aes(x = date, ymin = lo.95, ymax = hi.95, fill = "grey70"), alpha = 0.6, colour=NA) +
geom_ribbon(aes(x = date, ymin = lo.68, ymax = hi.68, fill = "blue"), alpha = 0.3, colour=NA) +
geom_line(data = subset(fc.df, type == "actual"), aes(x = date, y = zoo::rollmean(y, 7, na.pad = TRUE, align = "center")), col="red") +
scale_fill_manual(breaks = c("blue", "grey70"), values = c("blue", "grey70"), labels = c("68%", "95%"), name = "Prediction intervals") +
scale_size_manual(breaks = c("actual", "predicted"), values=c(1, 1.2)) +
scale_colour_manual(breaks = c("actual", "predicted"), values = c("black", "blue")) +
scale_x_date(date_labels = "%b %y", date_breaks = "1 month") +
# scale_y_continuous(limits = c(0, 16000), expand = c(0,0), breaks = c(0, 5000, 10000, 15000)) +
guides(colour=FALSE, size = FALSE) +
labs(title = "3 month download forecast",
subtitle = "Using TBATS model w/ ARMA errors & seasonality",
y = "Downloads") +
theme_vR() +
theme(
legend.justification=c(1, 1),
legend.position=c(0.95,0.95),
legend.title = element_text(size=11, face="bold"),
axis.title.x = element_blank())
# zoom plot
p + coord_cartesian(xlim = as.Date(c("2018-03-01","2018-10-01"))) +
scale_y_continuous(limits = c(0, 1500), expand = c(0,0))
fc.df
fc.df %>%
fitler(date >= "2018-06-01" & date <= "2018-06-30")
fc.df %>%
filter(date >= "2018-06-01" & date <= "2018-06-30")
fc.df %>%
filter(date >= "2018-06-01" & date <= "2018-06-30") %>%
summarise(sum(y))
fc.df %>%
filter(date >= "2018-06-01") %>%
mutate(month = lubridate::month(date))
?lubridate::month
fc.df %>%
filter(date >= "2018-06-01") %>%
mutate(month = lubridate::month(date)) %>%
group_by(month) %>%
summarise(total = sum(y))
